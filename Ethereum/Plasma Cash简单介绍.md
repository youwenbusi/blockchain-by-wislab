## 概述 ##
Plasma Cash是一个基于对Plasma链上的每个token使用惟一标识符的Plasma构造。与口袋里的现金类似，网络上的token有唯一的序列号。这种变化带来了许多好处。


- 客户端验证——客户端只需要观察Plasma链就可以得到他们的token。这意味着交易吞吐量可以在不增加单个用户负载的情况下进行扩展。


- 不需要多次确认——交易不再需要两个阶段的发送和确认。相反，一旦一个交易包含在主链中，它就可以被使用。

- 对所有token的简单支持——添加任何数量的不同token，没有额外的复杂性，包括不可替代资产。

- 较小的大规模退出缓解——大规模退出稍微不那么令人担忧，因为theif（偷窃者）必须为他们希望窃取的每个token提交一个退出事务。如果链暂停token仍然是安全的;然而，在服务中仍然有一个中断。

缺点是：
- 大的token面额——因为每个token都必须分配一个序列号，所以不能简单地使用小的token。这是因为在某种程度上，赎回token的gas成本将大于令牌本身的价值。

## 事务的根 ##
对于Plasma Cash链中的每个块，必须将merkle根发布到根链上。这个根可以是Merklist，也可以是Merkle Patricia Tree。在merklist中，叶节点的每个索引都对应于token ID，叶节点的值是Plasma交易。

交易形式:

[[prev_hash, prev_block, (target_block?), token_id, new_owner], signature]

使用给定的token_id的token开销的事务只有在位于token_id位置的Merkle树中包含该token时才有效;也就是说，对于每个token，Merkle树中只有一个“位置”允许交易花费该token。这种格式允许用户检查Plasma链的完整历史，并证明和证明其特定token的成员资格。这当然可以用更好的累加器进行优化。

## 铸造 ##

任何人都可以调用Plasma合约的deposit()函数，生成一个新的token（具有相同的eth数量）;对于ERC20 token，需要一个depositToken(address rec20, uint256 denomination)调用，它将提取在给定的ERC20合约地址中注册的所需token数量，并记录token类型(ERC20地址)和面额。

## 花费 ##
支出费用的人必须向收款人提供他们想要消费的特定token的完整历史。历史包括:


- 每次交易支出token包含在Plasma链中时，都必须提供Merkle证明。


- 对于每一个没有花费那个特定token的Plasma块，必须提供Merkle的不存在证明;也就是说，Merkle分支证明了在Merkle树中与硬币对应的索引处存在空数据，而不是有效的交易。

然后，接收方检查token的历史记录，查看是否有任何失效或阻塞。假设没有问题，接收者现在可以使用token。

## 退出 ##

退出允许用户在主链上取回token。任何具有token数据的用户都可以质疑无效的退出。每个退出还包括一笔保证金，其中包括一个挑战的gas费用加上证明无效的赏金。

用户可以自由地从侧链把存入的代币退出并转移回主链，但不排除作恶者获取了不义之财想卷款而逃的可能性。为了保证侧链上代币的安全，Plasma Cash在退出时加入了延时和挑战机制：
我们可以把侧链上代币的状态看作一个具有四种状态的状态机：DEPOSITED（存入），EXITING（待退出），CHALLENGED（被挑战）和EXITED（已退出）。
例如，当用户U把代币T存入侧链后，代币T处于DEPOSITED状态。当用户U想退出时，他可以发起startExit并附带一笔保证金bond1，startExit操作需要引用一笔交易TxA，用以证明代币T的所有权归属于用户U，以及TxA的“直接祖先”TxB，连同这两笔交易所在的区块。startExit提交成功之后代币就进入了EXITING状态。
如果一切顺利，7天之后用户U就可以光明正大地退出，代币T转为EXITED状态。
如果中途有人质疑，即退出请求遭遇挑战，则分三种情况：

challengeAfter——另一用户O发现了一笔在TxA之后的交易TxC可以证明代币T不属于用户U，用户O以此发起挑战，这种情况很容易得到验证，于是用户O赢得保证金bond1，代币T返回DEPOSITED状态；
challengeBetween——用户O发现了一笔在TxA和TxB之间的交易TxC可以证明代币T不属于用户U，用户O以此发起挑战，这种情况也很容易得到验证，于是用户O赢得保证金bond1，代币T返回DEPOSITED状态；
challengeBefore——用户O以一笔在TxB之前的交易TxC发起挑战，想要证明代币T不属于用户U，这种情况无法立即得到验证，所以用户O需要附加一笔保证金bond2，而且被挑战的用户U也有申诉的机会。此时代币T会进入CHALLENGED状态。如果申诉成功，保证金bond2由用户U获得，代币T回到EXITING状态。如果无法成功申诉，则退出请求失败，代币T返回初始状态DEPOSITED。




# 进一步的研究 #

## 部分花费 ##

实现部分支出的方法有很多。一个简单的解决方案是允许令牌id支持小数。然后可以将token分解成更小的块，然后在根链上退出。这种方法的一个缺点是，如果一个token分割得太小，那么它可能再次不值得退出。


理想情况下，可以拆分token，在Plasma链上进行交易，然后将一堆小令牌合并成一个大的，然后退出。这似乎很有可能，但这样做的规范仍在制定中。


## 紧凑花费历史 ##

如果执行得不好，验证token的历史记录可能会非常昂贵。如果事务列表中的非成员证明可以用最少的带宽轻松实现，那就太好了。理想情况下，可以使用历史的zkSTARK进行超快速紧凑令牌历史检查。

## 当出现无效的事务时能有效率的退出挑战 ##

在规范的最简单版本中，我们假设在一个无效的交易之后，所有现存的交易都是无效的。因此，如果您证明存在一个无效的状态转换，那么惟一可以退出的人就是包含无效交易之前token的所有者。这允许我们使退出逻辑超级简单。

理论上，在token的历史中，无效的状态转换没有问题。因为用户将验证每个token的历史，所以用户可以忽略无效的花费。然而，退出逻辑变得更加复杂。退出必须证明，不仅花费是有效的，而且在token的历史上没有无效的花费。可能有一些很好的方法可以有效地做到这一点，但那是开放的研究。
